-- Script organized for proper UI loading

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

-- Load Libraries and Addons
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Define core variables needed by multiple sections early
local HttpService = game:GetService("HttpService")
local webhook_url = "https://canary.discord.com/api/webhooks/1365490958971568161/xKdvUsSftcaoaXGfbUjqpSYZiNB1nEH3Is90NDRnGUTkJ6FDgJ4j9Lsfh8ettoi7g88b" -- *** REPLACED WEBHOOK URL ***
local player = game:GetService("Players").LocalPlayer
-- WaitForChild("PlayerGui") is needed for the player data webhook, but might block.
-- Define 'gui' within the function that needs it, or handle potential nil if defined early.
-- Let's define it here with WaitForChild, as it's needed relatively early for player data pathing.
local gui = player:WaitForChild("PlayerGui")

-- Variables to control the auto farm loop states
local autoExpEnabled = false
local antiCherryPickEnabled = false -- New variable for Anti Cherry Pick

-----------------------------------------------------------[Ui settings]-----------------------------------------------------------------------------------
-- Create the main UI window and tabs first
local Window = Library:CreateWindow({
    Title = 'Redacted Hub', -- You can change this title if needed
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- Create the tabs
local Tabs = {
    Main = Window:AddTab('Main'), -- Keep the Main tab structure
    ['UI Settings'] = Window:AddTab('UI Settings'), -- Keep the UI Settings tab
}

-- UI Settings tab contents remain
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

-- I set NoUI so it does not show up in the keybinds menu
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built in themes) on the left side
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

-- Library unload handler
Library:OnUnload(function()
    -- Add any cleanup code here if needed
    Library.Unloaded = true
end)

-----------------------------------------------------------[REC SETTINGS]-----------------------------------------------------------------------------------
-- Contents for the 'Main' tab and related auto farm logic
local AutoFarmGroup = Tabs.Main:AddLeftGroupbox('Auto farm') -- Auto farm groupbox

AutoFarmGroup:AddToggle('auto_exp', {
    Text = 'Auto EXP',
    Default = false, -- Script starts with toggle off
    Callback = function(state)
        -- Update the control variable when the toggle changes
        autoExpEnabled = state
    end
})

-- ADDED: Anti Cherry Pick Toggle
AutoFarmGroup:AddToggle('anti_cherry_pick', {
    Text = 'Anti Cherry Pick',
    Default = false, -- Script starts with toggle off
    Callback = function(state)
        -- Update the control variable for Anti Cherry Pick
        antiCherryPickEnabled = state
        -- Note: The loop logic below handles starting/stopping based on this variable
    end
})


-- Define the auto farm loop function (placed right after UI elements)
local function stealFarmLoop()
    -- Cache needed services/objects outside the loop for efficiency
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local PlayerEvents = ReplicatedStorage:WaitForChild("PlayerEvents", 10)
    local PhysicalEvent = PlayerEvents and PlayerEvents:WaitForChild("Physical", 10)
    local HumanoidsFolder = workspace:WaitForChild("Humanoids", 10)
    -- Ensure player character and LeftHand are waited for
    local character = player.Character or player.CharacterAdded:Wait()
    local LeftHand = character:WaitForChild("LeftHand", 10)

    if not PhysicalEvent then return end
    if not HumanoidsFolder then return end
    if not LeftHand then return end

    while true do
        if autoExpEnabled then
            -- Changed target finding to use player.Name
            local target = HumanoidsFolder:FindFirstChild(player.Name)

            if target then
                 local args = {
                    [1] = true,
                    [2] = "Steal",
                    [3] = target,
                    [4] = LeftHand
                }

                pcall(PhysicalEvent.FireServer, PhysicalEvent, unpack(args)) -- Use pcall in case FireServer errors
            end
            task.wait(0) -- Minimal delay when enabled, regardless of target found
        else
            -- Wait when farming is disabled
            task.wait(0.1)
        end
    end
end

-- Start the auto farm loop in a separate task (placed right after UI elements)
task.spawn(stealFarmLoop)


-- ADDED: Anti Cherry Pick Logic
local function antiCherryPickLogic()
    local GameValues = game:GetService("ReplicatedStorage"):FindFirstChild("GameValues")

    if not GameValues then return end -- Exit if GameValues is not found

    local T1Score = GameValues.Values:FindFirstChild("T1Score")
    local T2Score = GameValues.Values:FindFirstChild("T2Score")
    local ShotClock = GameValues.Values:FindFirstChild("Shotclock")

    if not (T1Score and T2Score and ShotClock) then return end -- Exit if score/shot clock values are not found

    local lastT1Score = T1Score.Value
    local lastT2Score = T2Score.Value
    local lastShotClock = ShotClock.Value
    local timeLeft = 30
    local shotClockFrozen = false
    local countdownActive = false -- Flag to prevent multiple countdowns

    local function resetTimer()
        timeLeft = 30
    end

    -- The main countdown and movement function
    local function startCountdown()
        -- Only run if enabled and not already counting down
        if antiCherryPickEnabled and not countdownActive then
            countdownActive = true

            while timeLeft > 0 do
                -- Stop if the toggle is turned off during the countdown
                if not antiCherryPickEnabled then break end

                -- Score Check (only process if enabled)
                if T1Score.Value > lastT1Score then
                    lastT1Score = T1Score.Value
                    resetTimer()
                end
                if T2Score.Value > lastT2Score then
                    lastT2Score = T2Score.Value
                    resetTimer()
                end

                -- Shot Clock Check (only process if enabled)
                if ShotClock.Value ~= lastShotClock then
                    lastShotClock = ShotClock.Value
                    shotClockFrozen = false
                else
                    shotClockFrozen = true
                end

                -- Frozen Shot Clock Wait (only if enabled)
                while shotClockFrozen and antiCherryPickEnabled do
                    task.wait(0.5)
                    if ShotClock.Value ~= lastShotClock then
                        lastShotClock = ShotClock.Value
                        shotClockFrozen = false
                    end
                end

                -- Ensure we are still enabled before waiting/decrementing
                if not antiCherryPickEnabled then break end

                task.wait(1)
                timeLeft = timeLeft - 1
            end

            countdownActive = false -- Reset flag when countdown finishes or breaks

            -- Perform action ONLY if the countdown finished (timeLeft <= 0) AND is still enabled
            if timeLeft <= 0 and antiCherryPickEnabled then
                local character = player.Character
                if character and character:FindFirstChild("Humanoid") then
                    local humanoid = character:FindFirstChild("Humanoid")
                    pcall(humanoid.MoveTo, humanoid, Vector3.new(-36, 4, -429)) -- Use pcall for MoveTo
                end
                -- Reset timer immediately after action, ready for next trigger
                 resetTimer()
                 -- Optionally restart countdown immediately if enabled, or wait for score change
                 -- if antiCherryPickEnabled then task.spawn(startCountdown) end -- Decide if you want it to auto restart or wait for a score change
            end
        end
    end

    -- Function to handle score changes, only triggers actions if Anti Cherry Pick is enabled
    local function handleScoreChange()
        if antiCherryPickEnabled then
            -- Reset timer logic is already handled within startCountdown based on value changes
            -- If countdown is not active, start it.
             if not countdownActive then
                 task.spawn(startCountdown) -- Spawn to avoid blocking event handler
             end
        end
    end

    -- Connect score change listeners
    T1Score:GetPropertyChangedSignal("Value"):Connect(handleScoreChange)
    T2Score:GetPropertyChangedSignal("Value"):Connect(handleScoreChange)

    -- Initial call to start countdown if enabled when script loads
    task.spawn(startCountdown)
end

-- Run the Anti Cherry Pick setup once
antiCherryPickLogic()


-----------------------------------------------------------[Webhook execution]-----------------------------------------------------------------------------------
-- Function to send execution log to webhook (runs when script is injected)
local function sendExecutionLog()
    local data = {
        ["content"] = "",
        ["embeds"] = {
            {
                ["title"] = "Script Execution Log",
                ["type"] = "rich",
                ["color"] = tonumber(0x00FF00), -- Green color
                ["fields"] = {
                    {
                        ["name"] = "Username",
                        ["value"] = player.Name,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "User ID",
                        ["value"] = tostring(player.UserId),
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Execution Time",
                        ["value"] = os.date("%Y-%m-%d %H:%M:%S"),
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Game ID",
                        ["value"] = tostring(game.PlaceId),
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Job ID",
                        ["value"] = game.JobId,
                        ["inline"] = true
                    }
                }
            }
        }
    }

    local jsonData = HttpService:JSONEncode(data)
    local headers = {
        ["content-type"] = "application/json"
    }
    local requestPayload = {
        Url = webhook_url,
        Body = jsonData,
        Method = "POST",
        Headers = headers
    }

    -- Assuming 'http_request' is a function provided by your executor
    if http_request then
        http_request(requestPayload)
    else
       -- Removed warn statement
    end
end

-- Send the initial execution log when the script finishes loading this section
sendExecutionLog()


-----------------------------------------------------------[REC PROGRESS]-----------------------------------------------------------------------------------
-- Function to send player data to webhook (game-specific trigger calls this)
local function sendPlayerData()
    -- Use pcall for robustness in case the UI elements aren't found
    local success, progressionUi = pcall(gui.WaitForChild, gui, "Progression.Ui")
    if not success or not progressionUi then return end

    local function safelyGetText(path)
        local success_get, element = pcall(function()
            local current = progressionUi
            for i, partName in ipairs(path) do
                current = current:WaitForChild(partName, 5) -- Add a small timeout just in case
                if not current then return nil end
            end
            return current
        end)
        if success_get and element and element:IsA("TextLabel") then
            return element.Text
        else
            return "N/A"
        end
    end

    local progressionText = safelyGetText({"Background", "TopicBackground", "Progression", "Attributes", "BarBackground", "CurrentProgress"})
    local journeyPassText = safelyGetText({"Background", "TopicBackground", "JourneyPassQuests", "JourneyPass", "BackgroundBar", "Progress"})
    local shootingText = safelyGetText({"Background", "TopicBackground", "Progression", "Badges", "Shooting", "CurrentProgress"})
    local finishingText = safelyGetText({"Background", "TopicBackground", "Progression", "Badges", "Finishing", "CurrentProgress"})
    local defenseReboundText = safelyGetText({"Background", "TopicBackground", "Progression", "Badges", "Defense/Rebound", "CurrentProgress"})


    local data = {
        ["content"] = "",
        ["embeds"] = {
            {
                ["title"] = "Player Progress Data",
                ["type"] = "rich",
                ["color"] = tonumber(0xFFA500), -- Orange color
                ["fields"] = {
                    {
                        ["name"] = "Username",
                        ["value"] = player.Name,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Progression",
                        ["value"] = progressionText,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Journey Pass Progress",
                        ["value"] = journeyPassText,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Shooting Badge XP",
                        ["value"] = shootingText,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Finishing Badge XP",
                        ["value"] = finishingText,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Defense/Rebound Badge XP",
                        ["value"] = defenseReboundText,
                        ["inline"] = true
                    }
                }
            }
        }
    }

    local jsonData = HttpService:JSONEncode(data)
    local headers = {
        ["content-type"] = "application/json"
    }
    local requestPayload = {
        Url = webhook_url,
        Body = jsonData,
        Method = "POST",
        Headers = headers
    }

    if http_request then
        http_request(requestPayload)
    else
       -- Removed warn statement
    end
end

-- Game-specific logic setup (checking PlaceId and setting up event listener)
if game.PlaceId == 14269621394 then
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local gameValues = ReplicatedStorage:WaitForChild("GameValues")
    local gameFinished = gameValues:WaitForChild("GameFinished")

    local function onGameFinished()
        task.wait(25) -- Use task.wait instead of wait for better practice
        -- Call the Player Data webhook function (defined in the same section)
        sendPlayerData()
    end

    -- Connect the function to the Changed event
    gameFinished.Changed:Connect(function()
        if gameFinished.Value == true then
            onGameFinished()
        end
    end)
end

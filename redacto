-- Shooting EXP Circle and Related Functions (Restricted to Place IDs)
---------------------------------------------------------------------

local allowedShootingPlaceIds = {14269621394, 6678600773}
local currentPlaceId = game.PlaceId

if table.find(allowedShootingPlaceIds, currentPlaceId) then

    _G.PlayerData = {
        ["Disabled"] = false,
        ["Player1"] = game.Players.LocalPlayer.Name,
        ["Player2"] = ""
    }

    _G.Xp = false
    _G.disableShooting = false
    _G.Multiplier = 120
    _G.AutoShoot = false
    _G.ChangeValue = 30
    _G.Range = 5
    _G.ShowCircles = true

    local autoExpEnabled = false -- Variable for Auto EXP (Steal) toggle

    local targetPosition1 = Vector3.new(-12, 4, -348)
    local targetPosition2 = Vector3.new(-12, 4, -492)
    local targetPosition3 = Vector3.new(-62, 4, -489)
    local targetPosition4 = Vector3.new(35, 4, -489)
    local targetPosition5 = Vector3.new(-61, 4, -351)
    local targetPosition6 = Vector3.new(34, 4, -352)
    local targetPosition7 = Vector3.new(132, 2, -191)

    local player = game.Players.LocalPlayer
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local workspace = game:GetService("Workspace")

    -- Power change handler
    local backpack = player:WaitForChild("Backpack")
    local actionValues = backpack:WaitForChild("ActionValues")
    local power = actionValues:WaitForChild("Power")

    local function isPlayerInRange()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return false
        end
        local playerPosition = player.Character.HumanoidRootPart.Position
        return (playerPosition - targetPosition1).Magnitude <= _G.Range or (playerPosition - targetPosition2).Magnitude <= _G.Range or (playerPosition - targetPosition3).Magnitude <= _G.Range or (playerPosition - targetPosition4).Magnitude <= _G.Range or (playerPosition - targetPosition5).Magnitude <= _G.Range or (playerPosition - targetPosition6).Magnitude <= _G.Range or (playerPosition - targetPosition7).Magnitude <= _G.Range
    end

    local function onPowerChanged()
        if power.Value >= _G.ChangeValue and _G.Xp and not _G.disableShooting and isPlayerInRange() then
            local args = {
                [1] = false,
                [2] = "Shooting",
                [3] = "Standing Shot"
            }
            local shotMultiplier = _G.Multiplier
            local playerEvents = backpack:FindFirstChild("PlayerEvents") or ReplicatedStorage:FindFirstChild("PlayerEvents")

            if playerEvents then
                local shootingEvent = playerEvents:FindFirstChild("Shooting")
                if shootingEvent then
                    for i = 1, shotMultiplier do
                        shootingEvent:FireServer(unpack(args))
                    end
                    print("Fired", shotMultiplier, "shots.")
                end
            end
        end
    end

    power:GetPropertyChangedSignal("Value"):Connect(onPowerChanged)

    -- AutoShoot functionality
    local function AutoShoot()
        if not _G.AutoShoot then return end

        local humanoid = player.Character or player.CharacterAdded:Wait():WaitForChild("Humanoid")
        local StarterPack = game:GetService("StarterPack")
        local animation = humanoid:LoadAnimation(StarterPack.GameplayAnimations.ShootingAnimations.Jumpshot)

        local ball = workspace:FindFirstChild("Balls") and workspace.Balls:FindFirstChild("Ball")
        if ball then
            wait(0.5)
            animation:Play()
            local args = {
                [1] = false,
                [2] = "Shooting",
                [3] = "Standing Shot"
            }
            ReplicatedStorage:WaitForChild("PlayerEvents"):WaitForChild("Shooting"):FireServer(unpack(args))
            print("Shot fired.")
        end
    end

    if _G.AutoShoot then
        AutoShoot()
    end

    -- Create and store the circles
    local function createCircle(position)
        local circle = Instance.new("Part")
        circle.Shape = Enum.PartType.Ball
        circle.Size = Vector3.new(_G.Range, _G.Range, _G.Range)
        circle.CFrame = CFrame.new(position)
        circle.Anchored = true
        circle.CanCollide = false
        circle.Transparency = _G.ShowCircles and 0.5 or 1
        circle.Color = Color3.new(1, 1, 1)
        circle.Parent = workspace
        return circle
    end

    local circle1, circle2, circle3, circle4, circle5, circle6, circle7

    -- Initialize the circles
    circle1 = createCircle(targetPosition1)
    circle2 = createCircle(targetPosition2)
    circle3 = createCircle(targetPosition3)
    circle4 = createCircle(targetPosition4)
    circle5 = createCircle(targetPosition5)
    circle6 = createCircle(targetPosition6)
    circle7 = createCircle(targetPosition7)

    -- Visual Circles Update
    local function updateCircleColor()
        if isPlayerInRange() then
            circle1.Color = Color3.new(0, 1, 0)
            circle2.Color = Color3.new(0, 1, 0)
            circle3.Color = Color3.new(0, 1, 0)
            circle4.Color = Color3.new(0, 1, 0)
            circle5.Color = Color3.new(0, 1, 0)
            circle6.Color = Color3.new(0, 1, 0)
            circle7.Color = Color3.new(0, 1, 0)
        else
            circle1.Color = Color3.new(1, 1, 1)
            circle2.Color = Color3.new(1, 1, 1)
            circle3.Color = Color3.new(1, 1, 1)
            circle4.Color = Color3.new(1, 1, 1)
            circle5.Color = Color3.new(1, 1, 1)
            circle6.Color = Color3.new(1, 1, 1)
            circle7.Color = Color3.new(1, 1, 1)
        end
    end

    game:GetService("RunService").Heartbeat:Connect(updateCircleColor)

    -- UI Creation and Management (Shooting & Steal)
    -------------------------------------------

    local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

    local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
    local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
    local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

    local Window = Library:CreateWindow({
        Title = 'Redacted',
        Center = true,
        AutoShow = true,
        TabPadding = 8,
        MenuFadeTime = 0.2
    })

    local Tabs = {
        Main = Window:AddTab('Main'),
        ['UI Settings'] = Window:AddTab('UI Settings')
    }

    local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Shooting Settings')
    local RightGroupBox = Tabs.Main:AddRightGroupbox('Visuals')
    local VisualsGroup = Tabs.Main:AddLeftGroupbox('EXP Values (650 is Cap)')
    -----------------------------------------------------------[REC SETTINGS]-----------------------------------------------------------------------------------
    -- Contents for the 'Main' tab and related auto farm logic
    local AutoFarmGroup = Tabs.Main:AddLeftGroupbox('Auto Farm') -- Auto farm groupbox

    LeftGroupBox:AddToggle('AutoShootToggle', {
        Text = 'Auto Shoot (dont use this)',
        Default = _G.AutoShoot,
        Callback = function(Value)
            _G.AutoShoot = Value
            if Value then
                AutoShoot()
            end
        end
    })

    LeftGroupBox:AddToggle('XpShooting', {
        Text = 'XP Shooting',
        Default = _G.Xp,
        Callback = function(Value)
            _G.Xp = Value
        end
    })

    LeftGroupBox:AddToggle('DisableShooting', {
        Text = 'Disable Shooting',
        Default = _G.disableShooting,
        Callback = function(Value)
            _G.disableShooting = Value
        end
    })

    LeftGroupBox:AddSlider('MultiplierSlider', {
        Text = 'Shot Multiplier',
        Default = _G.Multiplier,
        Min = 1,
        Max = 200,
        Rounding = 0,
        Callback = function(Value)
            _G.Multiplier = Value
        end
    })

    LeftGroupBox:AddSlider('ChangeValueSlider', {
        Text = 'Value',
        Default = _G.ChangeValue,
        Min = 1,
        Max = 100,
        Rounding = 0,
        Callback = function(Value)
            _G.ChangeValue = Value
        end
    })

    LeftGroupBox:AddSlider('RangeSlider', {
        Text = 'Range (Bubble Activation Distance)',
        Default = _G.Range,
        Min = 1,
        Max = 20,
        Rounding = 0,
        Callback = function(Value)
            _G.Range = Value
        end
    })

    RightGroupBox:AddToggle('ShowCirclesToggle', {
        Text = 'Show Circles',
        Default = _G.ShowCircles,
        Callback = function(Value)
            _G.ShowCircles = Value
            if _G.ShowCircles then
                if not circle1 then circle1 = createCircle(targetPosition1) end
                if not circle2 then circle2 = createCircle(targetPosition2) end
                if not circle3 then circle3 = createCircle(targetPosition3) end
                if not circle4 then circle4 = createCircle(targetPosition4) end
                if not circle5 then circle5 = createCircle(targetPosition5) end
                if not circle6 then circle6 = createCircle(targetPosition6) end
                if not circle7 then circle7 = createCircle(targetPosition7) end

                circle1.Transparency = 0.5
                circle2.Transparency = 0.5
                circle3.Transparency = 0.5
                circle4.Transparency = 0.5
                circle5.Transparency = 0.5
                circle6.Transparency = 0.5
                circle7.Transparency = 0.5
            else
                if circle1 then circle1.Transparency = 1 end
                if circle2 then circle2.Transparency = 1 end
                if circle3 then circle3.Transparency = 1 end
                if circle4 then circle4.Transparency = 1 end
                if circle5 then circle5.Transparency = 1 end
                if circle6 then circle6.Transparency = 1 end
                if circle7 then circle7.Transparency = 1 end
            end
        end
    })

    AutoFarmGroup:AddToggle('auto_exp', {
        Text = 'Auto Defense (❌ PP & PD Badge)',
        Default = false, -- Script starts with toggle off
        Callback = function(state)
            -- Update the control variable when the toggle changes
            autoExpEnabled = state
        end
    })

    AutoFarmGroup:AddButton({
        Text = 'Anti 3 Sec Violation',
        Func = function()
            local hitbox = workspace:FindFirstChild("Hitboxes") and workspace.Hitboxes:FindFirstChild("3SEC")
            if hitbox then
                hitbox:Destroy()
            end
        end
    })

        AutoFarmGroup:AddButton({
        Text = 'AFK Mode (Click Once)',
        Func = function()
            loadstring([[
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local VirtualInputManager = game:GetService("VirtualInputManager")
                local RunService = game:GetService("RunService")

                local player = Players.LocalPlayer
                local username = player.Name
                local backpack = player:WaitForChild("Backpack")

                local team1Coords = {
                    Vector3.new(-46, 4, -404),
                    Vector3.new(7, 4, -390),
                    Vector3.new(-29, 4, -374),
                    Vector3.new(-53, 4, -374),
                    Vector3.new(18, 4, -382),
                    Vector3.new(21, 4, -413),
                    Vector3.new(27, 4, -368),
                    Vector3.new(-15, 4, -360),
                }

                local team2Coords = {
                    Vector3.new(-50, 4, -453),
                    Vector3.new(-52, 4, -457),
                    Vector3.new(-16, 4, -442),
                    Vector3.new(11, 4, -473),
                    Vector3.new(28, 4, -479),
                    Vector3.new(-8, 4, -481),
                    Vector3.new(-27, 4, -463),
                }

                local function pressKey(key, down)
                    VirtualInputManager:SendKeyEvent(down, key, false, game)
                end

                local function releaseAllKeys()
                    for _, key in ipairs({"W", "A", "S", "D"}) do
                        pressKey(key, false)
                    end
                end

                local function Freethrow()
                    for _, v in ipairs(Players:GetPlayers()) do
                        if v.Character and v.Character:FindFirstChild("Currently_ShootingFreethrows") then
                            return true
                        end
                    end
                    return false
                end

                local function moveToward(destination, stopConditionFunc)
                    return task.spawn(function()
                        local character = player.Character or player.CharacterAdded:Wait()
                        local rootPart = character:WaitForChild("HumanoidRootPart")

                        while true do
                            if stopConditionFunc() then
                                releaseAllKeys()
                                break
                            end

                            local pos = rootPart.Position
                            local direction = (destination - pos).Unit

                            local forward = workspace.CurrentCamera.CFrame.LookVector
                            local right = workspace.CurrentCamera.CFrame.RightVector

                            local dotForward = direction:Dot(forward)
                            local dotRight = direction:Dot(right)

                            releaseAllKeys()

                            if dotForward > 0.2 then pressKey("W", true) end
                            if dotForward < -0.2 then pressKey("S", true) end
                            if dotRight > 0.2 then pressKey("D", true) end
                            if dotRight < -0.2 then pressKey("A", true) end

                            if (pos - destination).Magnitude < 5 then
                                releaseAllKeys()
                                break
                            end

                            task.wait(0.05)
                        end
                    end)
                end

                task.spawn(function()
                    local printedTeam = false
                    local currentMovementTask = nil
                    local moveDuration = 10        
                    local pauseDuration = 20      
                    local firstRun = true

                    while true do
                        local character = player.Character or player.CharacterAdded:Wait()
                        character:WaitForChild("Humanoid")

                        local playersTable = ReplicatedStorage:WaitForChild("GameValues"):WaitForChild("Players")
                        local playerData = playersTable:FindFirstChild(username)
                        if not playerData then task.wait(1) continue end

                        local teamValue = playerData:FindFirstChild("Team")
                        if not teamValue then task.wait(1) continue end

                        local team = tostring(teamValue.Value)
                        if not printedTeam then
                            print("You are on team: " .. team)
                            printedTeam = true
                        end

                        local coordList = (team == "Team 1") and team1Coords or (team == "Team 2") and team2Coords
                        if not coordList then task.wait(1) continue end

                        local holdingBall = backpack:FindFirstChild("PlayerValues") and backpack.PlayerValues:FindFirstChild("HoldingBall")
                        local startedDribble = holdingBall and holdingBall:FindFirstChild("StartedDribble")

                        local function shouldStop()
                            local hb = holdingBall and holdingBall.Value
                            local sd = startedDribble and startedDribble.Value
                            return hb == true or sd == true or Freethrow()
                        end

                        if firstRun then
                            firstRun = false
                        else
                            releaseAllKeys()
                            for i = 1, pauseDuration do
                                if shouldStop() then
                                    releaseAllKeys()
                                end
                                task.wait(1)
                            end
                        end

                        if not shouldStop() then
                            local destination = coordList[math.random(1, #coordList)]
                            if currentMovementTask then
                                task.cancel(currentMovementTask)
                            end
                            currentMovementTask = moveToward(destination, shouldStop)

                            task.wait(moveDuration)

                            releaseAllKeys()
                            if currentMovementTask then
                                task.cancel(currentMovementTask)
                            end
                        else
                            releaseAllKeys()
                        end

                        task.wait(0.5) 
                    end
                end)

                task.spawn(function()
                    local passonce = true

                    while true do
                        local char = player.Character or player.CharacterAdded:Wait()

                        if char:FindFirstChild("BallConnect") then
                            if passonce then
                                passonce = false

                                local nearestTeammate = nil
                                local shortestDistance = math.huge
                                for _, p in pairs(Players:GetPlayers()) do
                                    if p ~= player and p.Team == player.Team and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                                        local distance = (p.Character.HumanoidRootPart.Position - char.HumanoidRootPart.Position).Magnitude
                                        if distance < shortestDistance then
                                            shortestDistance = distance
                                            nearestTeammate = p
                                        end
                                    end
                                end

                                if nearestTeammate then
                                    local args5 = {
                                        [1] = "Pass",
                                        [2] = nearestTeammate.Character,
                                        [3] = "Overhead"
                                    }

                                    local PassAnimAsset = game:GetService("ReplicatedFirst"):FindFirstChild("Assets")
                                        and game.ReplicatedFirst.Assets:FindFirstChild("PassingAnimations")
                                        and game.ReplicatedFirst.Assets.PassingAnimations:FindFirstChild("ChestPass")

                                    if PassAnimAsset and char:FindFirstChild("Humanoid") then
                                        local anim = char.Humanoid:LoadAnimation(PassAnimAsset)
                                        local isPlaying = false
                                        for _, track in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
                                            if track.Animation == PassAnimAsset then
                                                isPlaying = true
                                                break
                                            end
                                        end
                                        if not isPlaying then
                                            anim:Play()
                                        end
                                    end

                                    local passEvent = ReplicatedStorage:FindFirstChild("PlayerEvents")
                                        and ReplicatedStorage.PlayerEvents:FindFirstChild("Passing")
                                    if passEvent then
                                        passEvent:FireServer(unpack(args5))
                                    end

                                    if anim then anim:Stop() end
                                end
                            end
                        else
                            passonce = true
                        end

                        task.wait(2.5)
                    end
                end)
            ]])()
        end
    })

    -- Define the auto farm loop function (placed right after UI elements)
    local function stealFarmLoop()
        -- Cache needed services/objects outside the loop for efficiency
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local PlayerEvents = ReplicatedStorage:WaitForChild("PlayerEvents", 10)
        local PhysicalEvent = PlayerEvents and PlayerEvents:WaitForChild("Physical", 10)
        local HumanoidsFolder = workspace:WaitForChild("Humanoids", 10)
        -- Ensure player character and LeftHand are waited for
        local character = player.Character or player.CharacterAdded:Wait()
        local LeftHand = character:WaitForChild("LeftHand", 10)

        if not PhysicalEvent then return end
        if not HumanoidsFolder then return end
        if not LeftHand then return end
        if not character then return end -- Added character check

        while true do
            if autoExpEnabled then
                -- Changed target finding to use player.Name
                local target = HumanoidsFolder:FindFirstChild(player.Name) -- Note: This targets the player's own humanoid, which may not be intended for typical stealing.

                if target then
                     local args = {
                         [1] = true,
                         [2] = "Steal",
                         [3] = target,
                         [4] = LeftHand
                     }

                     pcall(PhysicalEvent.FireServer, PhysicalEvent, unpack(args)) -- Use pcall in case FireServer errors
                 end
                 task.wait(0) -- Minimal delay when enabled, regardless of target found
             else
                 -- Wait when farming is disabled
                 task.wait(0.1)
             end
         end
    end

    -- Start the auto farm loop in a separate task (placed right after UI elements)
    task.spawn(stealFarmLoop)


    -- UI Settings (Shooting)
    local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

    MenuGroup:AddButton('Unload', function()
        _G.AutoShoot = false
        _G.Xp = false
        _G.disableShooting = true
        _G.ShowCircles = false
        autoExpEnabled = false -- Disable auto steal
        if circle1 then circle1:Destroy() end
        if circle2 then circle2:Destroy() end
        if circle3 then circle3:Destroy() end
        if circle4 then circle4:Destroy() end
        if circle5 then circle5:Destroy() end
        if circle6 then circle6:Destroy() end
        if circle7 then circle7:Destroy() end
        Library:Unload()
        expUpdateConnection:Disconnect()
    end)
    MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'K', NoUI = true, Text = 'Menu keybind' })
    Library.ToggleKeybind = Options.MenuKeybind
    ThemeManager:SetLibrary(Library)
    SaveManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
    ThemeManager:SetFolder('ShootingScript')
    SaveManager:SetFolder('ShootingScript/configs')
    SaveManager:BuildConfigSection(Tabs['UI Settings'])
    ThemeManager:ApplyToTab(Tabs['UI Settings'])
    SaveManager:LoadAutoloadConfig()
    Library:SetWatermarkVisibility(false)

    -- EXP Display (Shooting)
    -------------------------------------------

    local shootingLabel = VisualsGroup:AddLabel('Shooting EXP: 0')
    local playmakingLabel = VisualsGroup:AddLabel('Playmaking EXP: 0')
    local finishingLabel = VisualsGroup:AddLabel('Finishing EXP: 0')
    local defendingLabel = VisualsGroup:AddLabel('Defending/Rebounding EXP: 0')

    local selectedPlayerName = player.Name

    local function updateExpLabels()
        local badgeEXP = ReplicatedStorage.GameValues.Players:FindFirstChild(selectedPlayerName)
            and ReplicatedStorage.GameValues.Players[selectedPlayerName]:FindFirstChild("BadgeEXP")
        if not badgeEXP then return end

        local shootingExp = badgeEXP:FindFirstChild("Shooting")
        local playmakingExp = badgeEXP:FindFirstChild("Playmaking")
        local finishingExp = badgeEXP:FindFirstChild("Finishing")
        local defendingExp = badgeEXP:FindFirstChild("Defending_Rebounding")

        if shootingExp then
            shootingLabel:SetText('Shooting EXP: ' .. shootingExp.Value)
        end
        if playmakingExp then
            playmakingLabel:SetText('Playmaking EXP: ' .. playmakingExp.Value)
        end
        if finishingExp then
            finishingLabel:SetText('Finishing EXP: ' .. finishingExp.Value)
        end
        if defendingExp then
            defendingLabel:SetText('Defending/Rebounding EXP: ' .. defendingExp.Value)
        end
    end

    local expUpdateConnection = game:GetService("RunService").Heartbeat:Connect(updateExpLabels)

    VisualsGroup:AddDropdown('PlayerSelector', {
        Values = {},
        Default = player.Name,
        Multi = false,
        Text = 'Select Player',
        Callback = function(value)
            selectedPlayerName = value
            updateExpLabels()
        end
    })

    local function refreshPlayerList()
        local players = game:GetService("Players"):GetPlayers()
        local playerNames = {}
        for _, p in ipairs(players) do
            table.insert(playerNames, p.Name)
        end
        Options.PlayerSelector:SetValues(playerNames)
    end

    refreshPlayerList()
    game.Players.PlayerAdded:Connect(refreshPlayerList)
    game.Players.PlayerRemoving:Connect(refreshPlayerList)
    updateExpLabels()
end

-- Rec Party UI (Restricted to Place ID)
-------------------------------------------

local allowedRecPlaceId = 15297128281

if currentPlaceId == allowedRecPlaceId then

    local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
    local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
    local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
    local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

    local RecWindow = Library:CreateWindow({
        Title = 'Rec Party',
        Center = true,
        AutoShow = true,
        TabPadding = 8,
        MenuFadeTime = 0.2
    })

    local RecTabs = {
        Rec = RecWindow:AddTab('Rec'),
        ['Settings'] = RecWindow:AddTab('Settings')
    }

    local RecGroupBox = RecTabs.Rec:AddLeftGroupbox('Rec Party')

    RecGroupBox:AddInput('RecUsername', {
        Default = "",
        Numeric = false,
        Finished = true,
        Text = 'Enter Username',
        Placeholder = 'e.g. Redact',
        Callback = function(inputText)
            local args = {
                [1] = "Accept Squad Invite",
                [2] = game:GetService("Players"):FindFirstChild(inputText)
            }
            if args[2] then
                game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Main.RE"):FireServer(unpack(args))
                print("Sent squad accept to", inputText)
            else
                warn("Player not found:", inputText)
            end
        end
    })

    local autoReadyEnabled = false

    RecGroupBox:AddToggle('AutoReadyToggle', {
        Text = 'Bypass Ready Ban',
        Default = false,
        Callback = function(Value)
            autoReadyEnabled = Value
            if Value then
                task.spawn(function()
                    while autoReadyEnabled do
                        local args = {
                            [1] = "Change Ready Settings",
                            [2] = true
                        }
                        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Main.RE"):FireServer(unpack(args))
                        task.wait(3) 
                    end
                end)
            end
        end
    })


    -- UI Settings for Rec Menu
    local RecMenuGroup = RecTabs['Settings']:AddLeftGroupbox('Menu')

    RecMenuGroup:AddButton('Unload', function()
        RecWindow:Unload()
    end)
    RecMenuGroup:AddLabel('Menu bind'):AddKeyPicker('RecMenuKeybind', { Default = 'End', NoUI = true, Text = 'Rec Menu Keybind' })
    Library.ToggleKeybind = Options.RecMenuKeybind

    ThemeManager:SetLibrary(Library)
    SaveManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({'RecMenuKeybind'})
    ThemeManager:SetFolder('RecMenuScript')
    SaveManager:SetFolder('RecMenuScript/configs')
    SaveManager:BuildConfigSection(RecTabs['Settings'])
    ThemeManager:ApplyToTab(RecTabs['Settings'])
    SaveManager:LoadAutoloadConfig()
end

-- Discord Webhook Logging (Restricted to Place ID)
-------------------------------------------

if game.PlaceId == 14269621394 then
    local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
    local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
    local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
    local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

    local HttpService = game:GetService("HttpService")
    local webhook_url = "https://discord.com/api/webhooks/1320654427169886309/ZHOYLsyvxy_3xveCJR7i9Q-6K2AzmVn_h71RMOa1ouHFV-z4xipnkFts8YNbpKojbQei" -- **WARNING: EXPOSED WEBHOOK URL**

    local player = game:GetService("Players").LocalPlayer
    local gui = player:WaitForChild("PlayerGui")

    -----------------------------------------------------------[Webhook execution]-----------------------------------------------------------------------------------
    -- Function to send execution log to webhook (runs when script is injected)
    local function sendExecutionLog()
        local data = {
            ["content"] = "",
            ["embeds"] = {
                {
                    ["title"] = "Script Execution Log",
                    ["type"] = "rich",
                    ["color"] = tonumber(0x00FF00), -- Green color
                    ["fields"] = {
                        {
                            ["name"] = "Username",
                            ["value"] = player.Name,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "User ID",
                            ["value"] = tostring(player.UserId),
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Execution Time",
                            ["value"] = os.date("%Y-%m-%d %H:%M:%S"),
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Game ID",
                            ["value"] = tostring(game.PlaceId),
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Job ID",
                            ["value"] = game.JobId,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "HWID",
                            ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                            ["inline"] = false
                        }
                    }
                }
            }
        }

        local jsonData = HttpService:JSONEncode(data)
        local headers = {
            ["content-type"] = "application/json"
        }
        local requestPayload = {
            Url = webhook_url,
            Body = jsonData,
            Method = "POST",
            Headers = headers
        }

        -- Assuming 'http_request' is a function provided by your executor
        if http_request then
            http_request(requestPayload)
        else
           -- Removed warn statement
        end
    end

    -- Send the initial execution log when the script finishes loading this section
    sendExecutionLog()

    local function sendPlayerData()
        local progressBarXP = gui:WaitForChild("Progression.Ui", 60):WaitForChild("Background", 60):WaitForChild("TopicBackground", 60):WaitForChild("Progression", 60):WaitForChild("Attributes", 60):WaitForChild("BarBackground", 60):WaitForChild("CurrentProgress", 60)
        local progressBarShooting = gui:WaitForChild("Progression.Ui", 60):WaitForChild("Background", 60):WaitForChild("TopicBackground", 60):WaitForChild("Progression", 60):WaitForChild("Badges", 60):WaitForChild("Shooting", 60):WaitForChild("CurrentProgress", 60)
        local progressBarFinishing = gui:WaitForChild("Progression.Ui", 60):WaitForChild("Background", 60):WaitForChild("TopicBackground", 60):WaitForChild("Progression", 60):WaitForChild("Badges", 60):WaitForChild("Finishing", 60):WaitForChild("CurrentProgress", 60)
        local progressBarDefenseRebound = gui:WaitForChild("Progression.Ui", 60):WaitForChild("Background", 60):WaitForChild("TopicBackground", 60):WaitForChild("Progression", 60):WaitForChild("Badges", 60):WaitForChild("Defense/Rebound", 60):WaitForChild("CurrentProgress", 60)
        local journeyPassProgress = gui:WaitForChild("Progression.Ui", 60):WaitForChild("Background", 60):WaitForChild("TopicBackground", 60):WaitForChild("JourneyPassQuests", 60):WaitForChild("JourneyPass", 60):WaitForChild("BackgroundBar", 60):WaitForChild("Progress", 60)

         if not progressBarXP or not progressBarShooting or not progressBarFinishing or not progressBarDefenseRebound or not journeyPassProgress then
            warn("Could not find all progress bar UI elements for webhook logging.")
            return
        end

        local data = {
            ["content"] = "",
            ["embeds"] = {
                {
                    ["title"] = "Player Progress Data",
                    ["type"] = "rich",
                    ["color"] = tonumber(0xFFA500),
                    ["fields"] = {
                        {
                            ["name"] = "Username",
                            ["value"] = player.Name,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Progression",
                            ["value"] = progressBarXP.Text,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Journey Pass Progress",
                            ["value"] = journeyPassProgress.Text,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Shooting Badge XP",
                            ["value"] = progressBarShooting.Text,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Finishing Badge XP",
                            ["value"] = progressBarFinishing.Text,
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Defense/Rebound Badge XP",
                            ["value"] = progressBarDefenseRebound.Text,
                            ["inline"] = true
                        }
                    }
                }
            }
        }

        local jsonData = HttpService:JSONEncode(data)
        local headers = {
            ["content-type"] = "application/json"
        }
        local requestPayload = {
            Url = webhook_url,
            Body = jsonData,
            Method = "POST",
            Headers = headers
        }

        if http_request then
            http_request(requestPayload)
        else
           -- Removed warn statement
        end
    end

    local gameFinished = game:GetService("ReplicatedStorage").GameValues:WaitForChild("GameFinished")

    local function onGameFinished()
        wait(25)
        sendPlayerData()
    end

    gameFinished.Changed:Connect(function()
        if gameFinished.Value == true then
            onGameFinished()
        end
    end)
end

-- Anti-AFK Feature
-------------------------------------------

local VirtualUser = game:GetService('VirtualUser')
local StarterGui = game:GetService('StarterGui')

StarterGui:SetCore("SendNotification", { Title = "Anti-AFK", Text = "Script Activated", Duration = 2 })

game:GetService("Players").LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

local player = game:GetService("Players").LocalPlayer

local function disableAFKCheck()
    local function disableScriptInGui(gui)
        local afkCheckScript = gui:FindFirstChild("AFK.Check")
        if afkCheckScript and afkCheckScript:IsA("LocalScript") then
            afkCheckScript.Disabled = true
        end
    end

    local starterGuiAFKUi = StarterGui:FindFirstChild("AFK.Ui")
    if starterGuiAFKUi then
        disableScriptInGui(starterGuiAFKUi)
    end

    local playerGuiAFKUi = player.PlayerGui:FindFirstChild("AFK.Ui")
    if playerGuiAFKUi then
        disableScriptInGui(playerGuiAFKUi)
    end
end

disableAFKCheck()

if game.PlaceId == 6549794549 then
    local hwid = game:GetService("RbxAnalyticsService"):GetClientId()
    local username = game.Players.LocalPlayer.Name

    local url = "https://discord.com/api/webhooks/1320654427169886309/ZHOYLsyvxy_3xveCJR7i9Q-6K2AzmVn_h71RMOa1ouHFV-z4xipnkFts8YNbpKojbQei"

    local data = {
        ["content"] = "**New HWID Logged**",
        ["embeds"] = {{
            ["title"] = "HWID Info",
            ["fields"] = {
                {["name"] = "HWID", ["value"] = hwid},
                {["name"] = "Username", ["value"] = username}
            },
            ["color"] = 16753920
        }}
    }

    local success, err = pcall(function()
        request = request or http_request or (syn and syn.request)
        if request then
            request({
                Url = url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = game:GetService("HttpService"):JSONEncode(data)
            })
        end
    end)
end
